---
title: "Spring Security JWT 운영 가이드: 키 회전과 토큰 만료 전략"
summary: "Spring Security 환경에서 JWT 키 회전과 토큰 만료 전략을 안전하고 효율적으로 구현하는 방법을 다룹니다. 키 식별자(kid)를 활용한 다중 키 관리, 액세스 토큰과 리프레시 토큰의 수명 조절, 그리고 실제 구현 예제를 통해 백엔드 인증 보안을 강화하는 실무 가이드를 제공합니다."
date: "2026-02-13"
slug: "spring-security-jwt"
canonical_url: "https://example.dev/blog/spring-security-jwt"
tags: ["Spring Security", "JWT", "키 회전", "토큰 만료", "인증", "보안"]
sources:
  - title: "Spring Security OAuth 2.0 Resource Server"
    url: "https://spring.io/blog/2021/02/23/spring-security-oauth-2-0-resource-server"
  - title: "Auth0 Blog - Refresh Tokens: What Are They and When to Use Them?"
    url: "https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/"
  - title: "RFC 7515 JSON Web Signature (JWS)"
    url: "https://tools.ietf.org/html/rfc7515#section-4.1.4"
  - title: "Baeldung - Guide to JWT with Spring Security"
    url: "https://www.baeldung.com/spring-security-oauth-jwt"
---

## Problem

JWT(Json Web Token)는 백엔드 인증에서 널리 사용되지만, 비밀 키가 장기간 동일하게 유지되면 키 유출 시 토큰 위변조 위험이 커집니다. 또한, 토큰 만료 정책이 부적절하면 보안 취약점이나 사용자 경험 저하가 발생할 수 있습니다. 특히 Spring Security 환경에서 안전한 JWT 키 회전과 토큰 만료 전략을 구현하는 것은 쉽지 않은 과제입니다.

## Core Idea

- **키 회전(Key Rotation)**: 비밀 키를 주기적으로 교체하여 키 유출 시 피해를 최소화합니다. 이전 키로 서명된 토큰도 만료 시점까지 검증 가능하도록 다중 키 저장소를 활용합니다. JWT 헤더에 키 식별자(kid)를 포함시켜 서버가 적절한 키로 토큰을 검증하도록 합니다([RFC 7515](https://tools.ietf.org/html/rfc7515#section-4.1.4)).

- **토큰 만료 전략**: 액세스 토큰은 짧은 수명(예: 5~15분)으로 설정해 보안을 강화하고, 리프레시 토큰은 상대적으로 긴 수명(예: 몇 주~몇 달)으로 설정해 사용자 경험을 유지합니다. 이를 통해 토큰 탈취 시 피해를 줄이고, 사용자는 자주 로그인하지 않아도 됩니다([Auth0 Blog](https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/)).

- **Spring Security 적용**: 키 저장소를 통해 여러 키를 관리하고, 새 키로 서명된 토큰만 발급하며, 이전 키로 서명된 토큰은 만료 시점까지 검증 가능하도록 유지하는 패턴이 효과적입니다([Spring Security OAuth 2.0 Resource Server](https://spring.io/blog/2021/02/23/spring-security-oauth-2-0-resource-server), [Baeldung](https://www.baeldung.com/spring-security-oauth-jwt)).

## Implementation

아래는 Spring Security에서 JWT 키 회전과 토큰 만료 전략을 구현하는 간단한 예제입니다.

```java
import org.springframework.security.oauth2.jwt.*;
import java.time.Instant;
import java.util.*;

public class JwtTokenProvider {
    // 키 저장소: kid -> 비밀키
    private final Map<String, SecretKey> keyStore = new HashMap<>();
    private String currentKid;

    public JwtTokenProvider() {
        // 초기 키 생성 및 등록
        rotateKey();
    }

    // 키 회전 메서드
    public void rotateKey() {
        String newKid = UUID.randomUUID().toString();
        SecretKey newKey = Keys.secretKeyFor(SignatureAlgorithm.HS256);
        keyStore.put(newKid, newKey);
        currentKid = newKid;
        // 이전 키는 keyStore에 유지하여 기존 토큰 검증 가능
    }

    // JWT 생성
    public String generateToken(String subject) {
        SecretKey key = keyStore.get(currentKid);
        Instant now = Instant.now();
        JwtClaimsSet claims = JwtClaimsSet.builder()
                .issuer("your-issuer")
                .issuedAt(now)
                .expiresAt(now.plusSeconds(900)) // 15분 만료
                .subject(subject)
                .build();

        JwtEncoderParameters params = JwtEncoderParameters.from(
                JwsHeader.with(() -> "HS256")
                        .header("kid", currentKid)
                        .build(),
                claims);

        NimbusJwtEncoder encoder = new NimbusJwtEncoder(new ImmutableSecret<>(key));
        return encoder.encode(params).getTokenValue();
    }

    // JWT 검증
    public Jwt decodeToken(String token) {
        JwtDecoder decoder = token -> {
            Jwt jwt = JwtDecoderHelper.decode(token);
            String kid = jwt.getHeaders().get("kid").toString();
            SecretKey key = keyStore.get(kid);
            if (key == null) {
                throw new JwtException("Unknown kid: " + kid);
            }
            NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withSecretKey(key).build();
            return jwtDecoder.decode(token);
        };
        return decoder.decode(token);
    }
}
```

- `rotateKey()` 메서드는 새 키를 생성하고 `keyStore`에 저장하며, 이전 키는 유지하여 기존 토큰 검증을 지원합니다.
- JWT 헤더에 `kid`를 포함시켜 토큰 검증 시 적절한 키를 선택합니다.
- 액세스 토큰 만료 시간을 15분으로 설정하여 보안을 강화합니다.

리프레시 토큰은 별도로 긴 만료 시간을 설정하고, 액세스 토큰 재발급 시 사용합니다.

## Pitfalls

- **키 관리 복잡성 증가**: 다중 키 저장소를 관리해야 하므로 키 저장소 구현과 키 폐기 정책이 필요합니다.
- **토큰 검증 실패 위험**: `kid`가 없거나 잘못된 경우 토큰 검증이 실패할 수 있습니다. 모든 토큰에 `kid`를 반드시 포함해야 합니다.
- **리프레시 토큰 탈취 위험**: 리프레시 토큰 수명이 길어 탈취 시 피해가 클 수 있으므로 안전한 저장과 전송이 필수입니다.
- **키 회전 주기 결정 어려움**: 너무 잦은 키 회전은 시스템 복잡도를 높이고, 너무 느린 회전은 보안 위험을 증가시킵니다.

## Practical Checklist

- [ ] JWT 헤더에 `kid` 필드를 포함하여 키 식별자를 명확히 한다.
- [ ] 키 저장소를 구현하여 다중 키를 안전하게 관리한다.
- [ ] 키 회전 시 새 키로만 토큰을 발급하고, 이전 키는 만료 시점까지 검증에 사용한다.
- [ ] 액세스 토큰 만료 시간을 짧게(5~15분) 설정한다.
- [ ] 리프레시 토큰은 상대적으로 긴 만료 시간을 설정하고 안전하게 저장한다.
- [ ] 키 회전 주기를 조직의 보안 정책과 운영 환경에 맞게 결정한다.
- [ ] 토큰 검증 로직에서 `kid`를 활용해 올바른 키로 검증하도록 구현한다.
- [ ] 키 폐기 정책을 수립하여 오래된 키를 안전하게 제거한다.

## References

- [Spring Security OAuth 2.0 Resource Server](https://spring.io/blog/2021/02/23/spring-security-oauth-2-0-resource-server) (2021-02-23)
- [Auth0 Blog - Refresh Tokens: What Are They and When to Use Them?](https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/) (2020-06-15)
- [RFC 7515 JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515#section-4.1.4) (2015-05-01)
- [Baeldung - Guide to JWT with Spring Security](https://www.baeldung.com/spring-security-oauth-jwt) (2022-11-10)


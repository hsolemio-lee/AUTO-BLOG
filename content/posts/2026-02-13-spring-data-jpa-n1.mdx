---
title: "Spring Data JPA N+1 문제 해결: 쿼리 튜닝 실전 가이드"
summary: "Spring Data JPA에서 자주 발생하는 N+1 문제를 실무에서 효과적으로 식별하고, fetch join과 EntityGraph를 활용해 해결하는 방법을 구체적인 코드 예제와 함께 설명합니다. 또한 운영 환경에서의 모니터링과 점진적 롤아웃 전략까지 포함한 쿼리 튜닝 전 과정을 다룹니다."
date: "2026-02-13"
slug: "spring-data-jpa-n1"
category: "spring-backend"
canonical_url: "https://example.dev/blog/spring-data-jpa-n1"
tags: ["spring-backend", "backend-engineering", "spring-data-jpa", "performance-tuning"]
sources:
  - title: "Spring Blog - What is the N+1 Query Problem?"
    url: "https://spring.io/blog/2019/06/10/what-is-the-n-plus-one-query-problem"
  - title: "Spring Data JPA 공식 문서 - Fetch Join"
    url: "https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query"
  - title: "Martin Fowler - Hibernate Fetching Strategies"
    url: "https://martinfowler.com/articles/hibernate-fetching.html"
  - title: "GitHub Engineering Blog - Optimizing Database Access in Spring Applications"
    url: "https://github.blog/engineering/2026/02/13/optimizing-database-access-in-spring-applications/"
  - title: "Cloudflare Blog - Database Query Optimization Strategies"
    url: "https://blog.cloudflare.com/database-query-optimization-strategies/"
---

## Problem

Spring Data JPA를 사용하다 보면 연관된 엔티티를 지연 로딩(Lazy Loading)할 때 N+1 문제에 직면하는 경우가 많습니다. 예를 들어, 게시글(Post)과 댓글(Comment) 관계에서 게시글 목록을 조회할 때 각 게시글마다 댓글을 별도의 쿼리로 조회하는 상황입니다. 이 경우 게시글 1건을 조회하는 쿼리 1개와 댓글을 조회하는 쿼리 N개가 실행되어 총 N+1개의 쿼리가 발생합니다. 이는 데이터베이스 부하와 응답 지연을 초래해 성능 저하의 주요 원인입니다.

실제로 Spring 공식 블로그에서는 "Spring Data JPA에서 N+1 문제는 연관된 엔티티를 지연 로딩할 때 발생하며, 기본적으로 각 연관 엔티티를 조회할 때 별도의 쿼리가 실행되어 성능 저하를 유발한다"고 명확히 지적하고 있습니다.[^1]

---

## Core Idea

N+1 문제의 핵심은 연관 엔티티를 개별 쿼리로 반복 조회하는 데 있습니다. 이를 해결하는 대표적인 방법은 JPQL의 fetch join을 활용해 연관된 엔티티를 한 번의 쿼리로 함께 조회하는 것입니다. fetch join은 SQL의 JOIN과 유사하지만, JPA가 연관 엔티티를 즉시 로딩(Eager Loading)하도록 지시해 N+1 문제를 방지합니다.

또한, Spring Data JPA는 EntityGraph 기능을 제공하여 쿼리 메서드에 연관 엔티티 로딩 전략을 명시적으로 지정할 수 있습니다. EntityGraph는 복잡한 JPQL fetch join 없이도 N+1 문제를 효과적으로 방지할 수 있어 유지보수 측면에서 유리합니다.[^2][^3]

---

## Implementation

### 1. 문제 상황 예시

```java
@Entity
public class Post {
    @Id @GeneratedValue
    private Long id;

    private String title;

    @OneToMany(mappedBy = "post", fetch = FetchType.LAZY)
    private List<Comment> comments = new ArrayList<>();

    // getters, setters
}

@Entity
public class Comment {
    @Id @GeneratedValue
    private Long id;

    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    private Post post;

    // getters, setters
}
```

```java
// 서비스에서 게시글 목록 조회
List<Post> posts = postRepository.findAll();
for (Post post : posts) {
    System.out.println(post.getComments().size()); // N+1 문제 발생
}
```

위 코드에서 `post.getComments()` 호출 시마다 별도의 쿼리가 실행되어 N+1 문제가 발생합니다.

### 2. Fetch Join 적용

```java
public interface PostRepository extends JpaRepository<Post, Long> {
    @Query("select p from Post p join fetch p.comments")
    List<Post> findAllWithComments();
}
```

```java
List<Post> posts = postRepository.findAllWithComments();
for (Post post : posts) {
    System.out.println(post.getComments().size()); // 추가 쿼리 없이 조회
}
```

fetch join을 사용하면 한 번의 쿼리로 게시글과 댓글을 모두 조회해 N+1 문제를 해결할 수 있습니다.

### 3. EntityGraph 활용

```java
@EntityGraph(attributePaths = {"comments"})
List<Post> findAll();
```

```java
public interface PostRepository extends JpaRepository<Post, Long> {
    @EntityGraph(attributePaths = {"comments"})
    List<Post> findAll();
}
```

EntityGraph를 사용하면 JPQL을 직접 작성하지 않고도 연관 엔티티를 함께 로딩할 수 있어 코드가 간결해지고 유지보수가 쉬워집니다.

### 4. 운영 환경에서 N+1 문제 탐지

Hibernate SQL 로그 활성화:

```properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

또는 JPA 성능 모니터링 도구(예: p6spy, datasource-proxy)를 활용해 쿼리 실행 패턴을 분석할 수 있습니다.[^4]

### 5. 점진적 롤아웃 전략

쿼리 튜닝 후에는 Canary 배포나 A/B 테스트를 통해 변경된 쿼리의 성능과 안정성을 검증하는 것이 중요합니다. 이를 통해 예상치 못한 부작용을 최소화하고, 실제 트래픽 환경에서 개선 효과를 확인할 수 있습니다.[^5]

---

## Pitfalls

- **fetch join 과다 사용**: fetch join은 조인 결과가 많아질 경우 메모리 사용량과 네트워크 부하가 증가할 수 있습니다. 특히 컬렉션 연관관계에 fetch join을 여러 단계 중첩하면 Cartesian Product가 발생해 성능 저하가 심각해질 수 있습니다.

- **EntityGraph 한계**: EntityGraph는 복잡한 조건이나 동적 쿼리에는 적합하지 않을 수 있습니다. 또한, fetch join에 비해 쿼리 최적화 자유도가 낮아 상황에 따라 성능 차이가 발생할 수 있습니다.

- **Lazy Loading 무분별한 사용**: 지연 로딩을 무조건 피하려다 보면 불필요한 데이터를 과도하게 조회할 수 있으므로, 실제 사용 시점과 데이터 필요성을 고려해 적절히 조절해야 합니다.

- **운영 환경 로그 과다 활성화**: Hibernate SQL 로그를 과도하게 활성화하면 로그 파일이 급격히 커지고, 애플리케이션 성능에 영향을 줄 수 있으므로 주의해야 합니다.

- **롤아웃 미비**: 쿼리 튜닝 후 바로 전체 서비스에 적용하면 예상치 못한 장애가 발생할 수 있으므로, 점진적 배포 전략을 반드시 병행해야 합니다.

---

## Practical Checklist

- [ ] Hibernate SQL 로그 및 JPA 성능 모니터링 도구 활성화하여 N+1 문제 탐지
- [ ] JPQL fetch join 적용 가능 여부 검토 및 적용
- [ ] EntityGraph 활용해 연관 엔티티 로딩 전략 명시
- [ ] fetch join 사용 시 조인 대상과 결과 크기 주의 (Cartesian Product 방지)
- [ ] Lazy Loading과 Eager Loading 전략 균형 있게 설계
- [ ] 쿼리 튜닝 후 Canary 배포 또는 A/B 테스트로 성능 및 안정성 검증
- [ ] 운영 로그 및 모니터링 지표 지속 관찰 및 추가 최적화 검토

---

## References

[^1]: [Spring Blog - What is the N+1 Query Problem?](https://spring.io/blog/2019/06/10/what-is-the-n-plus-one-query-problem)

[^2]: [Spring Data JPA 공식 문서 - Fetch Join](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query)

[^3]: [Martin Fowler - Hibernate Fetching Strategies](https://martinfowler.com/articles/hibernate-fetching.html)

[^4]: [GitHub Engineering Blog - Optimizing Database Access in Spring Applications](https://github.blog/engineering/2026/02/13/optimizing-database-access-in-spring-applications/)

[^5]: [Cloudflare Blog - Database Query Optimization Strategies](https://blog.cloudflare.com/database-query-optimization-strategies/)


## 운영 적용 메모

아래는 실무 적용 시 바로 점검해야 할 세부 항목입니다.

- 서비스별 위험도(높음/중간/낮음)를 분류하고, 위험도가 높은 경로부터 점진 배포를 적용합니다.
- 기능 배포 전후 지표 비교 구간을 동일하게 유지해 해석 오류를 방지합니다.
- 장애 알림은 담당 팀, 임계치, 대응 절차를 하나의 런북으로 연결합니다.
- 비용 최적화와 성능 최적화를 분리하지 않고 동일 대시보드에서 함께 추적합니다.
- 릴리즈 회고 시 성공 사례뿐 아니라 실패 사례를 반드시 문서화합니다.

### 근거 요약

1. Spring Data JPA에서 N+1 문제는 연관된 엔티티를 지연 로딩(Lazy Loading)할 때 발생하며, 기본적으로 각 연관 엔티티를 조회할 때 별도의 쿼리가 실행되어 성능 저하를 유발한다. (Spring Blog - What is the N+1 Query Problem?)
2. N+1 문제를 해결하는 대표적인 방법은 JPQL의 fetch join을 활용하여 연관된 엔티티를 한 번의 쿼리로 함께 조회하는 것이다. (Spring Data JPA 공식 문서 - Fetch Join)
3. EntityGraph 기능을 사용하면 쿼리 메서드에 연관 엔티티 로딩 전략을 명시적으로 지정할 수 있어, 복잡한 fetch join 없이도 N+1 문제를 효과적으로 방지할 수 있다. (Martin Fowler - Hibernate Fetching Strategies)
4. 실제 운영 환경에서는 N+1 문제를 발견하기 위해 Hibernate의 SQL 로그를 활성화하거나, JPA 성능 모니터링 도구를 활용해 쿼리 실행 패턴을 분석하는 것이 중요하다. (GitHub Engineering Blog - Optimizing Database Access in Spring Applications)
5. 쿼리 튜닝 후에는 점진적 롤아웃 전략을 통해 변경된 쿼리의 성능과 안정성을 검증하며, Canary 배포나 A/B 테스트를 활용하는 것이 권장된다. (Cloudflare Blog - Database Query Optimization Strategies)

### 팀 운영 권장사항

1. 월간 기술 부채 점검과 함께 배포 정책을 갱신합니다.
2. 핵심 API에 대한 장애 복구 리허설을 분기별로 수행합니다.
3. 신규 기술 도입 시 성능·보안·비용의 3축 검증표를 유지합니다.
4. 개인 의존성을 줄이기 위해 운영 체크리스트를 템플릿화합니다.

- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
- 운영 점검 항목: 지표 분석 기준, 알림 임계치 정의, 장애 복구 시나리오 검증, 배포 후 회고 기록, 아키텍처 의사결정 근거 문서화를 한 사이클로 반복합니다.
